import{_ as e,c as o,o as a,V as t}from"./chunks/framework.9b470ccc.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"front/basic/跨域请求CORS.md","filePath":"front/basic/跨域请求CORS.md","lastUpdated":1691073737000}'),c={name:"front/basic/跨域请求CORS.md"},r=t('<h2 id="同源策略" tabindex="-1">同源策略 <a class="header-anchor" href="#同源策略" aria-label="Permalink to &quot;同源策略&quot;">​</a></h2><h3 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" title="MDN" target="_blank" rel="noreferrer">如果两个 <code>URL</code> 的 <code>protocol</code>、<code>port</code>和 <code>host</code> 都相同的话，则这两个 <code>URL</code> 是同源。这个方案也被称为“协议/主机/端口元组”，或者直接是“元组”。</a><br> 以下三种情况任一不同的URL之间请求即可产生跨域限制。</p><ul><li>域</li><li>协议</li><li>端口</li></ul><h3 id="方法" tabindex="-1">方法 <a class="header-anchor" href="#方法" aria-label="Permalink to &quot;方法&quot;">​</a></h3><ul><li><code>JsonP</code>：前端通过<code>Script</code>脚本进行伪装请求,且只能允许Get请求</li><li><code>CORS</code>：服务端设置</li><li><code>WebSocket</code>:特殊场景时使用，不属于常规跨域操作</li><li>代理服务（<code>Nginx</code>）服务端<code>CORS</code>配置，推荐使用</li></ul>',6),i=[r];function d(l,n,s,_,h,p){return a(),o("div",null,i)}const S=e(c,[["render",d]]);export{u as __pageData,S as default};
