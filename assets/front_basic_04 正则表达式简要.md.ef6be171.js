import{_ as e,c as o,o as c,V as d}from"./chunks/framework.494ce148.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"front/basic/04 正则表达式简要.md","filePath":"front/basic/04 正则表达式简要.md","lastUpdated":1691073737000}'),a={name:"front/basic/04 正则表达式简要.md"},r=d('<h2 id="字符" tabindex="-1">字符 <a class="header-anchor" href="#字符" aria-label="Permalink to &quot;字符&quot;">​</a></h2><h3 id="普通字符-字母-数字-汉字-等" tabindex="-1">普通字符：字母 数字 汉字 _ 等 <a class="header-anchor" href="#普通字符-字母-数字-汉字-等" aria-label="Permalink to &quot;普通字符：字母 数字 汉字 _ 等&quot;">​</a></h3><h3 id="特殊字符-点击查看" tabindex="-1">特殊字符：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-negated-character-set" target="_blank" rel="noreferrer">点击查看</a> <a class="header-anchor" href="#特殊字符-点击查看" aria-label="Permalink to &quot;特殊字符：[点击查看](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-negated-character-set)&quot;">​</a></h3><p><code>\\d</code>：数字0-9 <code>\\D</code>：非数字 <code>\\s</code>：空白符（空格 回车 tab） <code>\\S</code> ：非空白符 <code>\\w</code> <code>\\W</code></p><p><code>^</code>：匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。</p><p><code>$</code>：匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。</p><p><code>*</code>：匹配前一个表达式 0 次或多次。等价于 <code>{0,}</code>。</p><p><code>+</code>：匹配前面一个表达式 1 次或者多次。等价于 <code>{1,}</code>。</p><p><code>？</code>：匹配前面一个表达式 0 次或者 1 次。等价于 <code>{0,1}</code>。如果<strong>紧跟在任何量词 *、 +、? 或 {} 的后面</strong>，将会使量词变为<strong>非贪婪</strong>（匹配尽量少的字符），和缺省使用的<strong>贪婪模式</strong>（匹配尽可能多的字符）正好相反。</p><p><code>.</code>：（小数点）默认匹配除换行符之外的任何单个字符。如果 <code>s</code> (<code>dotAll</code>) 标志位被设为 true，它也会匹配换行符。</p><p><code>(x)</code>：像下面的例子展示的那样，它会匹配 <code>x</code>并且记住匹配项。其中括号被称为<em>捕获括号</em>。</p><p><code>(?:x)</code>：匹配 <code>x</code> 但是不记住匹配项。这种括号叫作<em>非捕获括号</em></p><p><code>x(?=y)</code>：匹配<code>x</code>仅仅当<code>x</code>后面跟着<code>y</code>.这种叫做先行断言。</p><p><code>(?&lt;=y)x</code>：匹配<code>x</code>仅当<code>x</code>前面是<code>y</code>.这种叫做后行断言。</p><p><code>x(?!y)</code>：仅仅当<code>x</code>后面不跟着<code>y</code>时匹配<code>x</code>，这被称为正向否定查找。</p><p><code>(?&lt;!y)x</code>：仅仅当<code>x</code>前面不是<code>y</code>时匹配<code>x</code>，这被称为反向否定查找。</p><p><code>x|y</code>：匹配<code>x</code>或者<code>y</code>。</p><p><code>{n}</code>：n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。比如， /a{2}/ 不会匹配“candy”中的<code>a</code>,但是会匹配“caandy”中所有的 a，以及“caaandy”中的前两个<code>a</code>。</p><p><code>{n,}</code>：n是一个正整数，匹配前一个字符至少出现了n次。例如, /a{2,}/ 匹配 <code>aa</code>, <code>aaaa</code> 和 <code>aaaaa</code> 但是不匹配 <code>a</code>。</p><p><code>{n,m}</code>：<code>n</code> 和<code>m</code> 都是整数。匹配前面的字符至少<code>n</code>次，最多<code>m</code>次。如果 <code>n</code> 或者<code>m</code> 的值是0， 这个值被忽略。</p><p><code>[xyz]</code>：一个字符集合。匹配方括号中的任意字符，包括<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types" target="_blank" rel="noreferrer">转义序列</a>。你可以使用破折号<code>-</code>来指定一个字符范围。</p><p><code>[^xyz]</code>：一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号<code>-</code>来指定一个字符范围。</p><p><code>[\\b]</code>：匹配一个退格<code>(U+0008)</code>。</p><p><code>\\b</code>：匹配一个词的边界。一个词的边界就是一个词不被另外一个<code>字</code>字符跟随的位置或者前面跟其他<code>字</code>字符的位置，例如在字母和空格之间。</p><p><code>\\B</code>：匹配一个非单词边界。匹配如下几种情况：</p><ul><li>字符串第一个字符为非<code>字</code>字符</li><li>字符串最后一个字符为非<code>字</code>字符</li><li>两个单词字符之间</li><li>两个非单词字符之间</li><li>空字符串</li></ul><p><code>\\d</code>：匹配一个数字。<code>等价于[0-9]</code>。</p><p><code>\\D</code>：匹配一个非数字字符。<code>等价于[^0-9]</code>。</p><p><code>\\n</code> 匹配一个换行符 (U+000A)。</p><p><code>\\r</code> 匹配一个回车符 (U+000D)。</p><p><code>\\s</code> 匹配一个空白字符，包括空格、制表符、换页符和换行符。</p><p><code>\\S</code> 匹配一个非空白字符。例如，<code>/\\S\\w*/</code> 匹配<code>foo bar.</code>中的<code>foo</code>。</p><p><code>\\t</code> 匹配一个水平制表符 (U+0009)。</p><p><code>\\v</code>：匹配一个垂直制表符 (U+000B)。</p><p><code>\\w</code>：匹配一个单字字符（字母、数字或者下划线）。等价于 <code>[A-Za-z0-9_]</code>。例如,<code>/\\w/</code>匹配 <code>apple,</code> 中的 <code>a</code>，<code>$5.28,</code>中的 <code>5</code> 和 <code>3D.</code> 中的 <code>3</code>。</p><p><code>\\W</code>：匹配一个非单字字符。</p><p><code>\\n</code>：在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。比如<code>/apple(,)\\sorange\\1/</code> 匹配<code>apple, orange, cherry, peach.</code>中的<code>apple, orange,</code> 。</p><h2 id="如何创建正则表达式对象" tabindex="-1">如何创建正则表达式对象？ <a class="header-anchor" href="#如何创建正则表达式对象" aria-label="Permalink to &quot;如何创建正则表达式对象？&quot;">​</a></h2><h3 id="对象的构造函数写法" tabindex="-1">对象的构造函数写法 <a class="header-anchor" href="#对象的构造函数写法" aria-label="Permalink to &quot;对象的构造函数写法&quot;">​</a></h3><p><code>var reg = new RegExp(para1，para2);</code> para需要写成字符串格式</p><ol><li><code>para1</code>:正则规则</li><li><code>para2</code>:规则属性 <ol><li><code>g</code>全局搜索。 <code>i</code>不区分大小写搜索。 <code>m</code> 多行搜索。 <code>s</code> 允许 . 匹配换行符。 <code>u</code> 使用<code>unicode</code>码的模式进行匹配。 <code>y</code> 执行“粘性(sticky)”搜索,匹配从目标字符串的当前位置开始。</li></ol></li></ol><h3 id="语法糖-字面量-创建写法" tabindex="-1">语法糖（字面量）创建写法 <a class="header-anchor" href="#语法糖-字面量-创建写法" aria-label="Permalink to &quot;语法糖（字面量）创建写法&quot;">​</a></h3><p>其由包含在斜杠之间的模式组成，<code>var reg = /para1/para2</code></p><h3 id="正则表达式-regexp-和字符串-string-的方法" tabindex="-1">正则表达式（RegExp）和字符串（String）的方法 <a class="header-anchor" href="#正则表达式-regexp-和字符串-string-的方法" aria-label="Permalink to &quot;正则表达式（RegExp）和字符串（String）的方法&quot;">​</a></h3><p><code>str.match(regexp)</code> 方法在字符串 <code>str</code> 中找到匹配 <code>regexp</code> 的字符。</p><ol><li>如果 <code>regexp</code> 不带有 <code>g</code> 标记，则它以数组的形式返回第一个匹配项，其中包含分组和属性<code>index</code>（匹配项的位置）、<code>input</code>（输入字符串，等于<code>str</code>）</li><li>如果 <code>regexp</code> 带有 <code>g</code> 标记，则它将所有匹配项的数组作为字符串返回，而不包含分组和其他详细信息。</li><li>如果没有匹配项，则无论是否带有标记 <code>g</code> ，都将返回 <code>null</code>。</li></ol><p><code>str.matchAll(regexp)</code> 是 <code>str.match</code> “新改进的”变体。</p><p><code>str.split(regexp|substr, limit)</code>使用正则表达式（或子字符串）作为分隔符来分割字符串。</p><p><code>str.search(regexp)</code> 返回第一个匹配项的位置，如果未找到，则返回 <code>-1</code> ; <strong>重要限制</strong>：<code>search</code> 仅查找第一个匹配项。</p><p>**<code>str.replace(str|regexp, str|func)</code>**当 <code>replace</code> 的第一个参数是字符串时，它仅替换第一个匹配项;第二个参数是一个替代字符串。我们可以在其中使用特殊字符;对于需要“智能”替换的场景，第二个参数可以是一个函数。</p><p><code>regexp.test(str)</code> 查找匹配项，然后返回 <code>true/false</code> 表示是否存在。如果正则表达式带有标记 <code>g</code>，则 <code>regexp.test</code> 从 <code>regexp.lastIndex</code> 属性中查找，并更新此属性,可以用它从给定位置进行搜索</p><h3 id="小问题" tabindex="-1">小问题 <a class="header-anchor" href="#小问题" aria-label="Permalink to &quot;小问题&quot;">​</a></h3><p>正则表达式引擎查找选择模式的时是挨个查找的。先匹配是否存在 <code>Java</code>，否则 —— 接着匹配 <code>JavaScript</code> 及其后的字符串。</p><ol><li>变更匹配顺序，长的字符串优先匹配：<code>JavaScript|Java|C\\+\\+|C|PHP</code>。</li><li>合并相同前缀：<code>Java(Script)?|C(\\+\\+)?|PHP</code>。</li></ol>',54),p=[r];function t(l,i,s,n,h,x){return c(),o("div",null,p)}const u=e(a,[["render",t]]);export{_ as __pageData,u as default};
